#### 网络模型

~~~
OSI七层模型            TCP/IP五层模型

7. 应用层         \ 
6. 表示层          >应用层(OSI模型中的5，6，7层)
5. 会话层         /
4. 传输层           传输层
3. 网络层           网络层
2. 数据链路层       数据链路层
1. 物理层           物理层

第一层到第四层也可以统一称为网络层
~~~


#### 网络拓扑

* 总线拓扑
* 环型拓扑
* 星状拓扑

#### CSMA/CD 协议

1. 我监听总线，来检测是否有其他机器发送信息（这是载波监听），或者是否有冲突发生（这是冲突检测）
2. 只有当没有其他机器发送信息时，我才能发送信息
3. 如果我开始发送信息时，正好也有其他机器开始发送信息，那么我们都停止发送
4. 产生冲突的机器分别等待随机的时间长度
5. 再尝试发送信息
6. 如果又发生冲突，回到第 4 步；如果没有冲突，则发送信息。

CSMA/CD 协议可以帮助我们解决总线拓扑的冲突，指两台或多台机器要在同一时刻发送信息

#### MAC 地址

网卡地址，全球唯一，MAC 地址是由 6 个字节编码的，用十六进制的形式来表示，每个字节（8 个二进制位）之间用冒号隔开，

例如
~~~
00:0c:29:10:5a:55
~~~
广播地址可以代表任意一个网卡，因此发向广播地址的信息就会发送到所在网络的所有网卡上。
~~~
ff:ff:ff:ff:ff:ff
~~~

#### 以太网

以太网帧如下：
|DST|SRC|第 3 层使用的协议|要发送的信息|CRC|
|-|-|-|-|-|

* DST 是 destination（目的地）的缩写，表示接收方
* SRC 是 source（源头）的缩写，表示发送方
* CRC 是循环冗余校验

帧头的格式是固定的，因此我们可以定义其大小：

* 接收方和发送方的 MAC 地址分别占用 6 个字节；
* 第 3 层的协议用 2 个字节编码；
* CRC 用 4 个字节编码。

6 x 2 + 2 + 4 = 18
因此以太网的帧头一共有 18 个字节。

以太网帧的最小尺寸是 64 字节
以太网帧的最大尺寸是 1518 字节。

#### 交换机

osi第二层，局域网通信

##### CAM表

交换机内存中存端口对应的mac地址，端口指交换机的接口，MAC地址指连接此交换机接口的设备对应的MAC地址

|端口|MAC地址|
|-|-|

当一个以太网帧发送到交换机后，CAM表被更新
|端口|MAC地址|
|-|-|
|1|机器1的MAC地址|

* 当交换机读取一个流经的帧，它就去更新 CAM 表；
* 如果交换机在它的 CAM 表中找不到此帧中的目标 MAC 地址，那么它就会把这个帧发送给除了此帧来源以外的所有机器
* 交换机不能主动地获知网络中的机器的 MAC 地址，而只能被动地得到MAC地址

##### TTL

CAM 表的生存时间

|端口|MAC地址|TTL|
|-|-|-|
|1|机器2的MAC地址|30秒|
|3|机器5的MAC地址|50秒|

TTL时间内发送消息给交换机，CAM表会被重置
交换机在每次接收到以太网帧的时候都会扩充 CAM 表的内容或者更新已有的内容。如果过了很久，交换机都没有收到任何帧，那么它的 CAM 表就会被清空。

#### 数据帧传输方式

* **单工** 数据传输是单向的。通信双方中，一方固定为发送端，另一方则固定为接收端，数据只能沿一个方向传输
* **半双工** 数据传输是双向的。数据在通信双方之间能够在两个方向上进行发送，但不能同时发送，因此又被称为双向交替通信。
* **全双工** 数据传输是双向的。通信双方在发送数据的同时也能够接收数据，两者可以同步进行

我们在集线器上，是在总线拓扑上，因此这些机器要以半双工的通信方式来交流，并且要用 CSMA / CD 协议，当一个交换机连接到集线器时，此时这个交换机的这个端口会自动切换为半双工

#### VLAN（虚拟局域网）

VLAN（虚拟局域网）是一种很优秀的技术，可以应用在交换机上，使得交换机的端口被分隔在不同的 VLAN 中，位于不同的 VLAN 中的机器不能相互通信。
|PORT|VLAN ID|
|-|-|
|1|2|
|2|5|

port代表交换机端口，vlan id代表vlan的编号，不同valn下的端口互相不能通信，例如上图中端口1和所在valn2，端口2在vlan5，端口1和端口2不能互相通信

对于 VLAN 来说，也是可以使属于两个 VLAN 的机器互相通信的，术语称为 VLAN Hopping 。hopping 表示“跳跃”，所以一般也称为 **VLAN 跳跃**。

#### 交换机环路

* 只需在两台甚至更多的交换机之间创建一个小回路：被称为“网络环路”；
* 或者将线缆的两端连接到同一台交换机：被称为“设备自环”。

过多广播帧，产生广播风暴，导致网络瘫痪

#### IP

##### 子网掩码

IP 地址的一部分代表网络的地址，另一部分代表机器的地址

* 子网掩码中为 1 的二进制位代表 IP 地址的网络部分（网络地址）。
* 子网掩码中为 0 的二进制位代表 IP 地址的主机部分（主机地址）。

子网掩码的 4 个字节中的每一个字节能取的值将始终是以下这些，而不能取其他值：
~~~
00000000 -> 0
10000000 -> 128
11000000 -> 192
11100000 -> 224
11110000 -> 240
11111000 -> 248
11111100 -> 252
11111110 -> 254
11111111 -> 255
~~~

##### 网络中地址数

网络中可用的 IP 地址数 = 2 的 “子网掩码中 0 的个数” 次方

* 地址范围中的第一个 IP 地址是这个网络的地址本身，此地址不能为某个主机所用
* 地址范围中的最后一个 IP 地址是一个特殊地址，即广播地址。该地址也不能为某个主机所用。实际上，它用于标识该网络中的所有主机。当我们向某网络的广播地址发送消息时，此网络上的所有主机都将收到此消息。

可用的主机数（等于 地址数 - 2）

##### RFC1918

RFC 1918 定义的私有 IP 地址范围是：

* 10.0.0.0 / 255.0.0.0 ：对应的地址范围是 10.0.0.0 ~ 10.255.255.255。被称为 A 类私有地址。
* 172.16.0.0 / 255.240.0.0 ：对应的地址范围是 172.16.0.0 ~ 172.31.255.255。被称为 B 类私有地址。
* 192.168.0.0 / 255.255.0.0 ：对应的地址范围是 192.168.0.0 ~ 192.168.255.255。被称为 C 类私有地址。

局域网内的私有ip地址最好使用上面的范围之内

##### CIDR

CIDR 表示法可以让我们通过一个斜杠（ / ）后接子网掩码中的 1 的位数（例如 /24 ）来简约地表示一个子网掩码；

将 192.168.0.1 / 255.255.255.0 简写为 192.168.0.1/24

24代表子网掩码的1的个数 --> 11111111.11111111.11111111.00000000

##### IP 数据报

|???|源IP地址(source)|目标IP地址(destination)|发送的信息|
|-|-|-|-|

第三层的数据包，目标ip在头部最后
当以太网帧穿过第二层时，该层读取帧的头部的目标 MAC 地址：

* 如果是我们的机器的网卡的 MAC 地址，就会读取帧的其余部分，然后将数据（实际上是 datagram（数据报））传输到第 3 层；
* 如果不是我们的机器的网卡的 MAC 地址，则不读取余下的信息，丢弃之（因为不是发给我们的网卡的）。

因此，如果消息到达了第 3 层，这必然意味着机器已经知道该消息是发给自己的，因为目标 MAC 地址是它自己的网卡的 MAC 地址。因此，它并不需要立即知道目标 IP 地址是否也是自己的 IP 地址，因为它已经知道此数据报是发给自己的。
因此，我们可以将目标 IP 地址放置在 IP 数据报的头部中的任意位置。IP 协议的发明者们并没有搞错！
此外，将 IP 地址放在数据报的头部的末尾的决定也不是随意为之的，主要是为了将第 3 层的重要信息放在离第 4 层的重要信息更近的地方。

* 以太网帧进阶版

|DST地址(接收方MAC)|SRC地址(发送方MAC)|第3层使用的协议|第三层头部|第四层头部|要发送的信息|CRC|
|-|-|-|-|-|-|-|

#### 路由

OSI第三层，网间通信 

路由追踪
traceroute  linux
tracert     windows

##### 路由器

* 路由器是一种具有多个网络接口的机器；
* 路由器的每个接口都连接到一个网络，因此路由器将多个网络链接在一起；
* 任何具有多个网络接口的机器都可以扮演路由器的角色，甚至是几十年前的一台电脑；
* 路由器不同于普通的机器，因为它可以分发（起到中继（relay）的作用）不是发给自己的数据包；
* 路由器通过路由表来分发数据包；
* 路由表指明了要使用哪个网关（Gateway）来加入一个网络

##### 路由表

路由表将列出可以向其发送数据报以到达给定目的地的路由器，路由表记录的是网络地址而不是某个ip地址

例:

|要连接的网络的地址|网关的 IP 地址|
|-|-|
|192.168.1.0/24|10.0.0.253|
|192.168.122.0/24|10.0.0.47|
|192.168.8.0/24|10.0.0.254|

编写路由表三部曲:

1. 写出本机连接的网络；
2. 写出默认路由；
3. 写出本机无法通过前面的两个步骤加入的所有其他网络。

##### 默认路由

如果我要加入的网络地址不属于路由表中的任何网络，则必须使用默认路由中指示的网关

本机通过网关访问不在本机所在得网络得其他机器

#### ARP协议

ARP 是 Address Resolution Protocol 的缩写，表示“地址解析协议”
ARP 协议是 OSI 第 2 层和第 3 层的协议，或者可以将其划归为介于第 2 层和第 3 层之间的协议。当然也有的著作将其划归为 OSI 第 3 层或第 2 层

* ARP协议可以通过ip获取对应的MAC地址，
* RARP协议通过MAC获取ip

arp通过发送arp广播，向广播地址发送消息，目标机器收到消息后把MAC地址返回给请求机器

##### ARP表

|IP地址|MAC地址|TTL| 
|-|-|-|
|192.168.1.2|01：02：03：04：05：06|30秒|
|192.168.2.2|11：22：33：44：55：66|50秒|

##### scapy

arp攻击，通过发送arp应答，在局域网内修改目标机器的arp表，即ip和对应的mac地址

https://github.com/secdev/scapy

#### ICMP 协议

* ICMP 协议用于在发生错误时自动指示错误；
* ICMP 协议可以提供排查网络问题的工具。

#### OSI第四层传输层

通过端口来标识应用程序

|应用程序|保留端口|
|-|-|
|http|80|
|https|443|
|ssh|22|
|ftp|20/21|
|dns|53|

##### UDP

UDP 是很简单的协议。由于 UDP 的目标是速度，并不需要知道信息是否被正确接收，因此发送的报文的格式是非常简单的。

UDP 数据报的格式:
|源端口号|目标端口号|总长度|checksun|要发送的信息|
|-|-|-|-|-|

每个区域都占 2 个字节，所以头部只需要 8 个字节。这是我们迄今为止看到的最小的头部了

* 源端口号（Source Port）：这很简单，它是发送信息的应用程序的地址。
* 目标端口号（Destination Port）：也很简单，它是接收信息的应用程序的地址。
* 数据报的总长度（单位是 Byte，byte 表示 “字节”，一个字节是 8 位二进制位，也就是 8 个 bit）：此区域占 2 字节（16 位二进制位），这意味着一个数据报的最大长度是 2 的 16 次方（等于 65536）个字节。但现实中，很少见到大于 512 字节的 UDP 数据报。这主要是因为丢失一个较小的数据报是可以接受的，但是丢失较大的数据报则比较麻烦，因为 UDP 对于丢失数据包置若罔闻。
* Checksum：表示 “校验和”，其原理与 OSI 第 2 层的以太网帧里的 CRC（循环冗余校验）类似，也是为了确保发送的数据和接收的数据是相同的。也许有些教材将这里的 Checksum 写成 CRC。CRC 和 Checksum 都属于冗余校验（Redundancy Check）。Checksum 是最简单的冗余校验。

##### TCP

可靠的 TCP 协议，TCP 是 Transmission Control Protocol 的缩写，表示 “传输控制协议”。
TCP 认为在一个方向上有一个通信，在另一个方向也有一个通信。因此，它为每个通信方向建立一个连接。所以说 TCP 是全双工（Full Deplex）的，即tcp会建立两条连接

|标志位|全称|释义|作用|
|-|-|-|-|
|SYN|synchronous|同步的|用于请求建立连接|
|ACK|acknowledgement|确认|表示确认号是否有效。我们称携带ACK标识的TCP报文段为确认报文段|
|FIN|finish|结束|用于结束连接，我们称携带FIN标志的TCP报文段为结束报文段|
|RST|reset|重置|用于重置连接，我们称携带RST标志的TCP报文段为复位报文段|
|PSH|push|推送|提示接收端应用程序应该立即从TCP接收缓冲区中读走数据|
|URG|urgent|紧急的|

* **建立连接(三次握手)**

~~~

1. client ---> SYN=1        ---> server
2. client <--- SYN=1,ACK=1  <--- server
3. client ---> ACK=1        ---> server

~~~

* **断开连接(四次挥手)**

~~~

1. client ---> FIN=1 ---> server
2. client <--- ACK=1 <--- server
3. client <--- FIN=1 <--- server
4. client ---> ACK=1 ---> server

~~~

###### TCP Segment（TCP 报文段）

|源端口号|目标端口号|？|标志位|?|checksum|??|要发送的信息|
|-|-|-|-|-|-|-|-|

头部20个字节

* 源端口号和目标端口号：各占 2 字节
* 标志位（flag）：一共有 6 个标志位，每个标志位占 1 个 ，所以一共是 6 Bit（二进制位）

###### Socket 套接字

socket 就是操作系统（Operating System）提供的独立于网络协议的一种抽象（abstraction）
本义为 **IP 地址 + 端口号**

#### NAT技术

* 静态NAT： 公有ip和私有ip 1对1绑定，不建议使用，没有解决ip4地址短缺问题
* 动态NAT： 让局域网中内私有ip地址的机器可以访问互联网

* 端口转发：其实就是将本地路由器的一个端口重定向到局域网中机器上的指定端口。

端口转发表：

|协议|外部 IP 地址|外部端口号|内部 IP 地址|内部端口号|
|-|-|-|-|-|
|TCP|117.148.64.237|80|192.168.0.1|80|



#### DNS 协议

域名和ip地址的对应
www.google.cn
以 **.** 区分，从右到左，最右边的cn是顶级域名，google是二级域名，www是三级域名

最多可以分支 127 层，每层最多由 63 个字符组成，中间用点（.）分隔。域名总长度不能超过 255 个字符，不区分大小写。可以是字母，数字，-，但是 - 不能为首

**.** 为dns根，在 DNS 级别上，www.google.cn 不能算是严格意义上的 FQDN，因为它漏写了最后的一个点 **.**。

##### 安装DNS服务器

以centos为例
~~~
yum install -y bind*
~~~

修改named.conf, 设为any
listen-on port 53 { any; }; 
allow-query     { any; }; 

~~~
$ vi /etc/named.conf

options {

        listen-on port 53 { any; };
        listen-on-v6 port 53 { ::1; };
        directory       "/var/named";
        dump-file       "/var/named/data/cache_dump.db";
        statistics-file "/var/named/data/named_stats.txt";
        memstatistics-file "/var/named/data/named_mem_stats.txt";
        recursing-file  "/var/named/data/named.recursing";
        secroots-file   "/var/named/data/named.secroots";
        allow-query     { any; };

...

include "/etc/named.rfc1912.zones"; 
include "/etc/named.root.key"; 
~~~

修改 named.rfc1912.zones 配置文件

~~~
新添加一个解析, 根域为saintkay.com, 文件名为saintkay.com.zone
zone "saintkay.com" IN {

        type master;
        file "saintkay.com.zone";
        allow-update { none; };
        allow-transfer { 192.168.1.12; };

}; 
~~~

* type 后面跟的是 master 或 slave, 配置dns服务器主从，不配置主从，则用master
* file 解析文件名，根据/etc/named.conf文件中的 **directory       "/var/named"; ** 决定解析文件位置，所以文件路径为 **/var/named/saintkay.com.zone**
* allow-update
* allow-transfer “允许传输”，就是指可以接收你的更新的服务器。当然，该指令仅在 type 为 master（主服务器）的情况下存在, 可以写多个具体的 DNS从服务器

dns解析文件 /var/named/saintkay.com.zone 如下

~~~
$TTL 1D
@       IN SOA  dns.saintkay.com. root.saintkay.com. (

                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3D )    ; minimum
        NS      dns.saintkay.com.
dns     A       192.168.1.11
www     A       192.168.1.11
a       A       192.168.1.11
b       A       192.168.1.12
~~~

* 第一个信息是 TTL（Time To Live 的缩写，表示“生存时间”）。当某台电脑去查询你的 DNS 服务器以获取信息时，此信息将被存储在它的 cache（缓存）中（也就是存储在它的 DNS 服务器的内存中，以防止它再次需要信息时重新询问你的 DNS 服务器）。TTL 表示信息保留在 cache 中的时长。超过此时间之后，再次需要信息时就必须对你的 DNS 服务器发出新请求，这里设置为1天
* SOA（Start Of Authority 的缩写，表示“授权的开始”）类型的记录。SOA 类型后面是两条信息。第一个是主域名服务器（master）的名称（此处是 dns.saintkay.com. ），第二个是域名管理员的电子邮件地址（此处是 root.saintkay.com.） ，这里是用点号（.）替换了通常邮件地址中的 @ 符号，因此域名管理员的邮件地址就是 root@saintkay.com ）。接下来，圆括号 () 中包含了不同的值：
  + Serial 表示“序列，序列号”，它里面有你所在区域的版本号。每次修改都应该增加这个版本号。这将告诉你的 DNS 服务器你的区域已更新，并且应该要发送通知到你的从属服务器。建议序列号采用 YYYYMMDDXX 的形式（YYYYMMDD 表示“年月日”。XX 是当前的版本。此处的 20200316 表示“2020年3月16日”；而 01 就是版本号，表示“第 1 版”），这也可以使你知道区域的最新更新日期
  + Refresh 表示“刷新”，是将记录存储在从属服务器上的时长。超过此时间之后，从属服务器将向主服务器请求新的更新。此处是 1D，表示 1天。
  + Retry 表示“重试”，是从属服务器等待重试的时间。也就是如果暂时无法连接到主服务器，再过多少时间重新尝试一次。此处是 1H，表示 1小时。
  + Expire 表示“期满，到期”，是从属服务器持续尝试与主服务器联系的时长。此处是 1w，表示1周。
  + Negative Cache TTL 表示“否定缓存的生存时间”，如果某个 DNS 服务器返回的结果是“你所查询的域名或者数据类型不存在”，则本地 DNS 服务器也会将该信息暂时放入缓存中。此处是 3D，表示 3天。
* SOA 记录的下方是其他主要的记录，分为 4 个部分（有时一些特殊的记录有 5 个部分）
  + 第一列信息是域（domain）的主机，可以选择留空白（指整个域），也可以是 @，或者是机器名称，或者是子域名。
  + 第二列信息代表分级。此处是 IN，表示这是一个和 Internet（Internet 表示“互联网”）有关的记录。IN 是 Internent 的前两个字母。除了 IN，也存在其他值，但是却并不被使用，所以我们总是输入 IN。
  + 第三列信息指定记录的类型
    - A 记录：这是最常见的记录类型，它将一个主机名与一个 IPv4 地址匹配；
    - AAAA 记录：将一个主机名与一个 IPv6 地址匹配；
    - CNAME 记录：用于创建指向另一个主机名的别名（alias）；
    - NS 记录：定义域名的 DNS 服务器；
    - MX 记录：定义域名的邮件服务器
    - PTR 记录：将 IP 对应于主机名，是 A 记录的逆向记录，负责将 IP 反向解析为域名。仅在反向区域中使用
    - SOA 记录：提供区域的信息，例如主 DNS 服务器，区域的管理员的电子邮件地址，区域的序列号，以及我们将详细说明的持续时间。
  + 第四列信息指定记录的值，根据记录的类型不同，值的样式也不同。例如，A 记录的值是 IP 地址，PTR 记录的值是主机名，等等

配置完之后 检查此文件，第一个参数是域，第二个是文件名
~~~
named-checkzone saintkay.com saintkay.com.zone
~~~

#### HTTP 协议

##### HTTP 

HTTP 是一种无状态（stateless）协议，HTTP 协议本身不会对发送过的请求和相应的通信状态进行持久化处理

HTTP/0.9 --> HTTP/1.0 --> HTTP/1.1 --> HTTP/2
我们目前用的最多的还是http1.1

1. **HTTP/0.9 客户端只能用GET，服务器只能回送HTML格式的字符串，其他数据不支持**
2. **HTTP/1.0 短连接，连接无法复用、线头阻塞（head of line blocking）、带宽和延迟、支持cache，相比0.9增加了POST、HEAD**
3. **HTTP/1.1 长连接，（客户端pipelining）服务端线头阻塞，Host字段、断电续传、相比1.0增加了PUT、PATCH、DELETE**
4. **HTTP/2 多路复用、通信单位为二进制帧、并行通信、数据流模式（无序，编号+ID+（优先权））、首部压缩（索引号查数据）、服务器推送**

**HTTP/0.9** 1991年发布的0.9版。只有一个命令GET，服务器只能回应HTML格式的字符串，不能回应别的格式，务器发送完毕，就关闭TCP连接。

**HTTP/1.0** 1996年5月，HTTP/1.0 版本发布，除了GET命令，还引入了POST命令和HEAD命令，任何格式的内容都可以发送，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。
HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求，为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段：Connection: keep-alive 这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段：Connection: keep-alive 一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接

**HTTP/1.1** 

1999，HTTP/1.1 版本发布，
新增功能：

* 引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive，客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。

不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接
目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。

* 引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求，而不需要等待服务器响应，但是服务器只能根据客户端发送请求的顺序来响应, 虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的

~~~
http/1.0 请求方式 
client ---> a请求     ---> server
client <--- 响应a请求 <--- server
client ---> b请求     ---> server
client <--- 响应b请求 <--- server

http/1.1 请求方式
client ---> a请求     ---> server
client ---> b请求     ---> server
client <--- 响应a请求 <--- server
client <--- 响应b请求 <--- server
~~~

* 协议中共定义了九种方法（也叫“动作”）来以不同方式操作指定的资源：
  * GET ：get 表示“得到，获得”。请求指定的资源信息，并返回实体主体。
  * HEAD ：head 表示“头，头部”。类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。
  * POST ：post 表示“张贴，公布，邮递”。向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和已有资源的修改。
  * PUT ：put 表示“放，放置”。从客户端向服务器传送数据，取代指定的文档的内容。
  * DELETE ：delete 表示“删除”。请求服务器删除指定的资源。
  * TRACE ：trace 表示“跟踪”。HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
  * OPTIONS ：option 表示“选项”。允许客户端查看服务器的性能。
  *  CONNECT ：connect 表示“连接”。回显服务器收到的请求，主要用于测试或诊断。
  *  PATCH ：patch 表示“补丁”。是对 PUT 方法的补充，用来对已知资源进行局部更新。

**HTTP/2**

* 二进制分帧: HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制, HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）, 并对它们采用二进制格式的编码
* 多工: 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。

~~~
client ---> a请求 ---> server
client ---> b请求 ---> server
client <--- 响应a请求-1 <--- server
client <--- 响应b请求   <--- server
client <--- 响应a请求-2 <--- server
~~~

* 头信息压缩机制（header compression）： HTTP 协议不带有状态，每次请求都必须附上所有信息，头信息使用gzip或compress压缩后再发送；客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，对于同样的字段，只发送索引号

* 服务器推送 HTTP/2 允许服务器未经请求，主动向客户端发送资源

常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。
服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。

##### HTTPS

HTTP + SSL/TLS = HTTPS

安全传输过程

对称加密+非对称加密(一般使用RSA)
非对称加密太消耗电脑资源了。非对称加密比对称加密要慢大概 100 ~ 1000 倍，所以正常数据传输过程中使用对称加密，非对称加密加密 对称加密密钥，然后用对称加密密钥来进行数据传输

ssh，https等安全传输过程
~~~
client <--- tcp三次握手建立连接  ---> server
client <--- 非对称加密公钥       <--- server
client ---> 公钥加密的对称加密密钥   ---> serve ---> 用非对称加密私钥解密"对称加密密钥"，得到"对称加密密钥"
client <--- 对称加密密钥加密的信息   ---> server
~~~

HTTPS 协议的 RFC 文档很小，只有短短的 7 页，里面规定了新的协议名，默认端口号 443。至于其他的应答模式、报文结构、请求方法、URI、头字段、连接管理，等等都完全沿用 HTTP 协议，没有任何新的东西。

SSL 或 TLS 协议是 HTTPS 之所以安全的保障。因此，HTTPS 其实并不是一项新的应用层协议，只是 HTTP 通信接口部分由 SSL 和 TLS 替代而已。

SSL 协议在 OSI 七层网络模型中位于第五层（会话层，Session Layer）。SSL 在 1999 年被 IETF（互联网工程组）更名为 TLS。SSL 协议已经不再被认为是安全的了，现在我们使用的是 TLS 协议。

TLS 协议主要有以下的作用：

* 使用对称加密来确保数据的保密性；
* 使用 MAC（Message Authentication Code 的缩写，表示“消息认证码”）码来确保数据的完整性；
* 使用非对称加密来确保会话密钥的交换；
* 使用证书颁发机构（CA，是 Certificate Authority 的缩写。certificate 表示“证书”，authority 表示“权威，权力机构”）签署的证书来确保服务器的认证。
