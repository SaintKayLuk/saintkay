# shell概述

hell是用户和Linux内核之间的接口程序，linux命令通过shell去调用内核

# shell分类

|shell类别|简称||
|-|-|-|
|Bourne      |sh  |被bash向下兼容取代
|Korn Shell  |ksh |
|Bourne Again|bash|linux默认shell
|POSIX Shell |psh |
|C Shell     |csh |被tcsh向下兼容取代
|TC Shell    |tcsh|


# shell执行方式

1. 赋予执行权限，直接运行，通过路径找到此文件
2. 通过bash调用 例：bash 文件名

# shell文件格式
~~~
 #!/bin/bash
 ...
~~~
第一行定义此文件是shell脚本文件

# bash基本功能

## echo

~~~
echo [选项] [输出内容]
    -e  支持反斜线控制的字符转换，控制字符如下
    -n  取消输出后行末的换行符(输出内容后不换行，默认一个echo输出内容后会换行)


控制字符     作用
\\          输出 \ 本身
\a          输出警告音
\b          退格键，也就是向左删除
\c          取消输出行末的换行符，和 -n 选项作用一致
\e          EXCAPE键
\f          换页符
\n          换行符
\r          回车键
\t          制表符，相当于 Tab 键
\v          垂直制表符
\0nnn       按照八进制 ASCII 码表输出字符 0 是数字0 ，nnn是三位八进制数
\xhh        按照十六进制 ASCII 码表输出字符， x 是小写字母x ，hh 是两位十六进制数

~~~

echo 输出颜色

\e[1; 代表颜色输出开始
\e[0m 代表颜色输出结束

31m 代表红色字体，32代表绿色字体等

例：输出红色的 abc 字符
~~~
[root@localhost ~] echo -e "\e[1; 31m abc \e[0m"
~~~

## 历史命令

~~~
history
    -c  清空历史命令
    -w  把缓存中的历史命令写入历史命令保存文件，默认位于 ~/.bash_history
~~~

history 命令查看的历史命令是 ~./bash_history 文件中加缓存中的历史命令，默认退出登陆会把本次登陆的历史命令写入 ~/.bash_history w文件，也可以使用 history -w 来手动保存

历史命令保存条数默认1000条，在 /etc/profile 文件中修改
~~~
[root@localhost ~]# vi /etc/profile
...
HISTSIZE=1000
...
~~~

调用历史命令

1. 使用上下箭头查看历史命令
2. 使用 !n 来执行第n条历史命令
3. 使用 !! 来执行上一条命令
4. 使用 !字符 来执行最后一条以该字符开头的命令 
5. 使用 !$ 执行上一条命令的最后一个参数

## 别名

~~~
alias 别名='原命令'

例：
alias vi='vim'
~~~

通过alias命令设置的别名是临时生效，永久生效写入 ~/.bashrc 文件中

### 命令执行的顺序

1. 绝对路径或相对路径执行的命令，例如 /bin/vi 就是执行的vi命令
2. 别名
3. 执行bash的内部命令
4. 按照 $PATH 环境变量定义的目录查找顺序找到的第一个命令


## bash常用快捷键

|快捷键|作用|
|-|-|
|ctrl+A|光标移动到命令行开头|
|ctrl+E|光标移动到命令行结尾|
|ctrl+C|强制终止当前命令|
|ctrl+L|清屏，相当于clear命令|
|ctrl+U|删除或剪切光标之前的内容|
|ctrl+K|删除或剪切光标之后的内容|
|ctrl+Y|粘贴 ctrl+U 或 ctrl+K 剪切的内容|


## 输入输出重定向


|设备|设备文件名|文件描述符|类型|
|-|-|-|-|
|键盘  |/dev/stdin |0|标准输入|
|显示器|/dev/stdout|1|标准输出|
|显示器|/dev/stderr|2|标准错误输出|


### 输出重定向
~~~
>  覆盖
>> 追加
~~~
标准输出重定向，>后面有空格
~~~
命令 > 文件
命令 >> 文件
~~~
标准错误输出重定向，>后面没有空格
~~~
错误命令 2>文件
错误命令 2>>文件
~~~
正确输出和错误输出同时保存
~~~
命令 > 文件 2>&1        
命令 >> 文件 2>&1       
命令 &>文件             
命令 &>>文件                
命令>>文件1 2>>文件2        正确输出追加到文件1，错误输出追加到文件2
~~~
### 输入重定向
~~~
wc [选项] [文件名]
    -c  统计字节数
    -w  统计单词数
    -l  统计行数
~~~


## 多命令顺序执行


~~~
:       命令1 : 命令2           多个命令按顺序执行，命令之间没有逻辑关系
&&      命令1 && 命令2          当命令1正确执行，命令2才会执行
||      命令1 || 命令2          当命令1执行不正确，则命令2才会执行，当命令1正确执行，命令2不会执行
~~~


## bash中特殊符号


### 通配符
用于匹配文件名，完全匹配，find 命令搜索文件命名中可以使用通配符
~~~
?   匹配一个任意字符
*   匹配0个或多个任意字符，也可以匹配任意内容
[]  匹配中括号中任意一个字符，[abc] 代表匹配a,b,c其中一个，一个中括号代表匹配一个字符
    [-]中间加 - ，例如[a-z],代表一个小写字母
    [^] 取反，例如[^0-9],代表匹配一个不是数字的字符
~~~

### 正则表达式
用于匹配字符串，包含匹配，grep 搜索文件中内容使用正则

~~~
?   匹配前一个字符重复0次或1次          --只能用egrep命令来使用
*   匹配前一个字符重复0次或任意多次
[]  匹配中括号中任意一个字符，[abc] 代表匹配a,b,c其中一个，一个中括号代表匹配一个字符
    [-]中间加 - ，例如[a-z],代表一个小写字母
    [^] 取反，例如[^0-9],代表匹配一个不是数字的字符
^   匹配行首
$   匹配行尾
~~~

### 其他

|符号|作用|
|-|-|
|'' |单引号，在单引号中所有的特殊符号( $ ``)等都没有意义|
|"" |双引号，在双引号中特殊符号没有特殊含义，但是 $ ` \ 是例外，拥有 调用变量的值，引用命令， 转义符的特殊含义|
|·· |反引号，反引号括起来的内容是系统命令，在bash中会先执行他，和 $()作用一样|
|$()|和反引号作用一样，用来引用系统命令|
|() |用于一串命令执行时，()中的命令会在子shell中执行|
|{} |用于一串命令执行时，{}中的命令会在当前shell中执行，也可以用户变量变形和替换|
|[] |用于变量的测试|
|#  |在shell脚本中，#开头的行表示注释|
|$  |用于调用变量的值，如需要调用变量 name 的值，需要使用 $name 的方式得到变量的值|
|\  |转义符，跟在 \ 之后的特殊符号将数去特殊含义|


反引号一般用于把系统命令的值复制给一个变量 
例：把date命令的输出，即当前日期赋值给变量a
~~~
[root@localhost ~]# a=`date`
~~~

小括号()和大括号{}的主要区别有：

* ()执行一串命令时，需要重新开一个子shell进行执行
* {}执行一串命令时，是在当前shell执行
* ()和{}都是把一串命令放在括号里面，并且命令之间用 ; 隔开
* ()最后一个命令可以不用分号
* {}最后一个命令需要使用分号
* {}的第一个命令和左括号之间必须要有一个空格
* ()里的各命令不必和括号有空格
* ()和{}中括号里面的某个命令的重定向只影响该命令，但括号外的重定向则影响到括号里的所有命令

## bash的变量和运算符


































