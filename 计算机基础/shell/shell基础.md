# shell概述

hell是用户和Linux内核之间的接口程序，linux命令通过shell去调用内核

# shell分类

|shell类别|简称||
|-|-|-|
|Bourne      |sh  |被bash向下兼容取代
|Korn Shell  |ksh |
|Bourne Again|bash|linux默认shell
|POSIX Shell |psh |
|C Shell     |csh |被tcsh向下兼容取代
|TC Shell    |tcsh|


# shell执行方式

1. 赋予执行权限，直接运行，通过路径找到此文件
2. 通过bash调用 例：bash 文件名

# shell文件格式
~~~
 #!/bin/bash
 ...
~~~
第一行定义此文件是shell脚本文件

# bash基本功能

## echo

~~~
echo [选项] [输出内容]
    -e  支持反斜线控制的字符转换，控制字符如下
    -n  取消输出后行末的换行符(输出内容后不换行，默认一个echo输出内容后会换行)


控制字符     作用
\\          输出 \ 本身
\a          输出警告音
\b          退格键，也就是向左删除
\c          取消输出行末的换行符，和 -n 选项作用一致
\e          EXCAPE键
\f          换页符
\n          换行符
\r          回车键
\t          制表符，相当于 Tab 键
\v          垂直制表符
\0nnn       按照八进制 ASCII 码表输出字符 0 是数字0 ，nnn是三位八进制数
\xhh        按照十六进制 ASCII 码表输出字符， x 是小写字母x ，hh 是两位十六进制数

~~~

echo 输出颜色

\e[1; 代表颜色输出开始
\e[0m 代表颜色输出结束

31m 代表红色字体，32代表绿色字体等

例：输出红色的 abc 字符
~~~
[root@localhost ~] echo -e "\e[1; 31m abc \e[0m"
~~~

## 历史命令

~~~
history
    -c  清空历史命令
    -w  把缓存中的历史命令写入历史命令保存文件，默认位于 ~/.bash_history
~~~

history 命令查看的历史命令是 ~./bash_history 文件中加缓存中的历史命令，默认退出登陆会把本次登陆的历史命令写入 ~/.bash_history w文件，也可以使用 history -w 来手动保存

历史命令保存条数默认1000条，在 /etc/profile 文件中修改
~~~
[root@localhost ~]# vi /etc/profile
...
HISTSIZE=1000
...
~~~
修改之后需要重新加载配置文件，让其生效
~~~
[root@localhost ~]# source /etc/profile
[root@localhost ~]# . /etc/profile
~~~

source命令和 . 作用一致

在linux中 . 的作用
* 作用同source一致，重新加载配置文件
* ./ 代表当前目录
* .文件名，文件名前面加一个点，代表隐藏文件


调用历史命令

1. 使用上下箭头查看历史命令
2. 使用 !n 来执行第n条历史命令
3. 使用 !! 来执行上一条命令
4. 使用 !字符 来执行最后一条以该字符开头的命令 
5. 使用 !$ 执行上一条命令的最后一个参数

## 别名

~~~
alias 别名='原命令'

例：
alias vi='vim'
~~~

通过alias命令设置的别名是临时生效，永久生效写入 ~/.bashrc 文件中

### 命令执行的顺序

1. 绝对路径或相对路径执行的命令，例如 /bin/vi 就是执行的vi命令
2. 别名
3. 执行bash的内部命令
4. 按照 $PATH 环境变量定义的目录查找顺序找到的第一个命令


## bash常用快捷键

|快捷键|作用|
|-|-|
|ctrl+A|光标移动到命令行开头|
|ctrl+E|光标移动到命令行结尾|
|ctrl+C|强制终止当前命令|
|ctrl+L|清屏，相当于clear命令|
|ctrl+U|删除或剪切光标之前的内容|
|ctrl+K|删除或剪切光标之后的内容|
|ctrl+Y|粘贴 ctrl+U 或 ctrl+K 剪切的内容|


## 输入输出重定向


|设备|设备文件名|文件描述符|类型|
|-|-|-|-|
|键盘  |/dev/stdin |0|标准输入|
|显示器|/dev/stdout|1|标准输出|
|显示器|/dev/stderr|2|标准错误输出|


### 输出重定向
~~~
>  覆盖
>> 追加
~~~
标准输出重定向，>后面有空格
~~~
命令 > 文件
命令 >> 文件
~~~
标准错误输出重定向，>后面没有空格
~~~
错误命令 2>文件
错误命令 2>>文件
~~~
正确输出和错误输出同时保存
~~~
命令 > 文件 2>&1        
命令 >> 文件 2>&1       
命令 &>文件             
命令 &>>文件                
命令>>文件1 2>>文件2        正确输出追加到文件1，错误输出追加到文件2
~~~
### 输入重定向
~~~
wc [选项] [文件名]
    -c  统计字节数
    -w  统计单词数
    -l  统计行数
~~~


## 多命令顺序执行


~~~
:       命令1 : 命令2           多个命令按顺序执行，命令之间没有逻辑关系
&&      命令1 && 命令2          当命令1正确执行，命令2才会执行
||      命令1 || 命令2          当命令1执行不正确，则命令2才会执行，当命令1正确执行，命令2不会执行
~~~


## bash中特殊符号


### 通配符
用于匹配文件名，完全匹配，find 命令搜索文件命名中可以使用通配符
~~~
?   匹配一个任意字符
*   匹配0个或多个任意字符，也可以匹配任意内容
[]  匹配中括号中任意一个字符，[abc] 代表匹配a,b,c其中一个，一个中括号代表匹配一个字符
    [-]中间加 - ，例如[a-z],代表一个小写字母
    [^] 取反，例如[^0-9],代表匹配一个不是数字的字符
~~~

### 正则表达式
用于匹配字符串，包含匹配，grep 搜索文件中内容使用正则

~~~
?   匹配前一个字符重复0次或1次          --只能用egrep命令来使用
*   匹配前一个字符重复0次或任意多次
[]  匹配中括号中任意一个字符，[abc] 代表匹配a,b,c其中一个，一个中括号代表匹配一个字符
    [-]中间加 - ，例如[a-z],代表一个小写字母
    [^] 取反，例如[^0-9],代表匹配一个不是数字的字符
^   匹配行首
$   匹配行尾
~~~

### 其他

|符号|作用|
|-|-|
|'' |单引号，在单引号中所有的特殊符号( $ ``)等都没有意义|
|"" |双引号，在双引号中特殊符号没有特殊含义，但是 $ ` \ 是例外，拥有 调用变量的值，引用命令， 转义符的特殊含义|
|·· |反引号，反引号括起来的内容是系统命令，在bash中会先执行他，和 $()作用一样|
|$()|和反引号作用一样，用来引用系统命令|
|() |用于一串命令执行时，()中的命令会在子shell中执行|
|{} |用于一串命令执行时，{}中的命令会在当前shell中执行，也可以用户变量变形和替换|
|[] |用于变量的测试|
|#  |在shell脚本中，#开头的行表示注释|
|$  |用于调用变量的值，如需要调用变量 name 的值，需要使用 $name 的方式得到变量的值|
|\  |转义符，跟在 \ 之后的特殊符号将数去特殊含义|


反引号一般用于把系统命令的值复制给一个变量 
例：把date命令的输出，即当前日期赋值给变量a
~~~
[root@localhost ~]# a=`date`
~~~

小括号()和大括号{}的主要区别有：

* ()执行一串命令时，需要重新开一个子shell进行执行
* {}执行一串命令时，是在当前shell执行
* ()和{}都是把一串命令放在括号里面，并且命令之间用 ; 隔开
* ()最后一个命令可以不用分号
* {}最后一个命令需要使用分号
* {}的第一个命令和左括号之间必须要有一个空格
* ()里的各命令不必和括号有空格
* ()和{}中括号里面的某个命令的重定向只影响该命令，但括号外的重定向则影响到括号里的所有命令

## 变量

变量

* 变量命令可以由 字母，数字 下划线组成， 但不能以数字开头
* 变量默认都是字符串类型
* 定义变量用等号，等号两边不能有空格，因为linux系统中空格会认为是命令。例如a=123，定义变量a的值为123,
* 变量的值如果有空格，则需单引号或者双引号包括，例 test="hello world"。
* 变量的值中，可以使用 \ 转义符
* 变量的值可以叠加，但是需要用 "$变量名" 或 ${变量名} 来使用
* 如果把命令的结果作为变量值赋值给变量，则需要使用 `` 或 $() 包含命令
* 环境变量名建议大写

例：变量的叠加
~~~
[root@localhost ~]# test=123
[root@localhost ~]# test="$test"456
[root@localhost ~]# echo $test
123456
~~~

### 变量的分类

* 用户自定义变量：名称：自定义，作用：自定义，内容：自定义
* 环境变量
  * 用户自定义环境变量：名称：自定义，作用：自定义，内容：自定义
  * 系统自带环境变量：名称：确定，作用：确定，内容：可以修改
* 位置参数变量：名称：自定义，作用：自定义，内容：自定义
* 预定义变量：名称：自定义，作用：自定义，内容：自定义

### 用户自定义变量
~~~
变量名=变量的内容

例：
[root@localhost ~]# test=123
~~~

变量调用
~~~
$变量名

例：输出变量名为test的内容
[root@localhost ~]# echo $test
123
~~~

变量查看
~~~
set [选项]
    -u  设定此选项，调用未声明的变量会报错，默认调用未声明的变量输出为空，不会报错
    -x  设定此选项，在命令执行之前，会把命令输出一次

例：查看变量
[root@localhost ~]# set
BASH=/bin/bash
...
~~~

通过set命令可以看到一部分变量，包括用户自定义变量
通过env命令也可以看到一部分变量，但不会显示用户自定义变量

set 命令加 env 命令可以看全所有变量

set命令设置是临时生效，永久生效需要写入对应配置文件

变量删除
~~~
unset 变量名
~~~

### 环境变量

#### 用户自定义环境变量

环境变量设置
~~~
export 变量=变量值
~~~

环境变量删除
~~~
unset 变量名
~~~

环境变量查看
~~~
env     
set
~~~


#### 系统环境变量

通过env查看环境变量
~~~
env
~~~

##### PATH 变量
系统查找命令的路径
~~~
[root@localhost ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
~~~

PATH变量的值用 : 分隔的路径，是系统查找命令的路径，当直接输入命令时，会在 PATH 变量的值的这些路径里去查找命令，如果都没有，才会报错。

让用户自定义的脚本或命令能够直接运行，而不需要加路径执行的两种方式。
1. 把命令cp到 PATH 变量的现有值中或 添加软链接到 PATH 变量现有的值中
2. 修改 PATH 变量的值，把自定义命令或者脚本文件的绝对路径添加到PATH变量中

##### PS1 变量

定义命令行的提示符
~~~
[root@localhost ~]# echo $PS1
[\u@\h \W]\$
~~~

~~~
\d      显示日期，格式为 "星期 月 日"
\H      显示完整的主机名，如默认主机名 localhost.localdomain
\h      显示简写的主机名，如默认的 localhost
\t      显示24小时制，格式为 HH:MM:SS
\T      显示12小时制，格式为 HH:MM:SS
\A      显示24小时制，格式为 HH:MM
\@      显示12小时制，格式为 HH:MM am/pm
\u      显示当前用户名
\v      显示bash版本信息
\w      小写w，显示当前所在目录的完整名称
\W      大写W，显示当前所在目录的最后一个目录
\#      执行的第几个命令
\$      提示符，如果是root用户提示符为 # ，如果是普通用户提示符为 $
~~~

例：修改命令行提示符为 [用户名@时间 完整路径]提示符，然后 cd 到其他目录看一下
~~~
[root@localhost ~]# PS1='[\u@\t \w]\$ '
[root@15:36:49 ~]# cd /usr/local/bin/
[root@15:36:54 /usr/local/bin]# 
~~~
注意要用单引号

##### LANG 变量

查看当前登陆终端的语言编码
~~~
[root@localhost ~]# echo $LANG
zh_CN.UTF-8
~~~

查看当前系统的语系
~~~
[root@localhost ~]# locale
LANG=zh_CN.UTF-8
LC_CTYPE="zh_CN.UTF-8"
...
~~~

或者查看系统支持的语系,几乎所有语言都支持
~~~
[root@localhost ~]# locale -a
aa_DJ
aa_DJ.iso88591
...
~~~

远程工具登陆的终端可以支持中文，主机自带的终端默认是英文，也只能显示英文

#### 位置参数变量


|位置参数变量|作用|
|-|-|
|$n|n为数字，$1到$9代表第一个到第九个参数，十以上得参数需要用大括号包含，如${10}|
|$*|命令行中所有的参数，把所有参数当成一个整体，多个参数for循环只会循环一次|
|$@|命令行中所有的参数，把每个参数区别对待，多个参数for循环的时候会循环多次|
|$#|代表命令行中所有参数的个数|

例：通过$n来获取位置参数，\$@获取所有参数，并区分，\$#获取参数个数
```sh
[root@localhost ~]# cat test.sh
#!/bin/bash
echo $1
echo $2
echo "====="
for i in "$@"
    do
        echo $i
    done
echo "====="
echo $#
[root@localhost ~]# ./test.sh 11 22 33
11
22
=====
11
22
33
=====
3
```

#### 预定义变量

|预定义变量|作用|
|-|-|
|$?|最后一次执行的命令的返回状态，返回数字0或者其他，返回0则上一次执行的命令正确，返回非0则上一次命令执行错误|
|$$|当前进程的进程号(PID)|
|$!|后台运行的最后一个进程的进程号(PID)|

#### read

位置参数变量使用比较不友好， read可以提示输入

~~~
read [选项] [变量名]
    -p "提示信息"   在等待read输入时，输出提示信息
    -t 秒数         read命令会一直等待用户输入，此选项选择等待秒数，等待时间内用户没有输入，会结束脚本
    -n 字符数       允许输入的最大字符数，达到指定字符数会自动回车
    -s              隐藏输入的数据，类似于登陆时输入密码
~~~

例：通过read提示用户输入，允许最大输入字符数为2，并且等待输入30秒
```sh
[root@localhost ~]# cat test.sh
#!/bin/bash
read -t 30 -n 3 -p "请输入姓名：" name 
echo $name  

[root@localhost ~]# ./test.sh
请输入姓名：sk
sk
```

## 数值运算

### 数值运算方法

#### 使用declare声明变量类型
因为shell默认变量为字符串类型，我们在做数值运算的时候可以使用declare声明变量类型为数值
```sh
declare [+/-] [选项] 变量名
    -   给变量设定类型属性
    +   取消变量的类型属性
        a   将变量声明为数组
        i   将变量声明为整数
        r   将变量声明为只读属性，一旦设置为只读属性，此变量不能改变值，也不能被删除，更不能通过 +r 取消只读属性，此声明是通过命令是临时生效的，重启失效
        x   将变量声明为环境变量
        p   显示指定的被声明的类型
```
**-是设定属性，+是取消属性**
-x 声明的环境变量，和 export 命令作用是一样，export 命令其实就是通过 declare -x 来设定为环境变量,
~~~
[user@localhost ~]$ declare -x age=18
~~~

例：通过给c设置属性为整数型，会把a+b作为数值运算
```sh
[user@localhost ~]$ a=11
[user@localhost ~]$ b=22
[user@localhost ~]$ declare -i c=$a+$b
[user@localhost ~]$ echo c
33
```

例：声明数组类型,通过 ${数组名[*]} 获取数组中所有值
```sh
[user@localhost ~]$ declare -a name[0]="pa"
[user@localhost ~]$ name[1]="spe"
[user@localhost ~]$ name[2]="jugg"
[user@localhost ~]$ echo ${name[*]}
pa spe jugg
```
通过 declare -p 来查看所有变量,也可以指定变量名来查看某个变量 declare -p 变量名
```sh
[user@localhost ~]$ declare -p
declare -- BASH="/bin/bash"
declare -r BASHOPTS="checkwinsize:cmdhist:expand_aliases:extquote:force_fignore:histappend:hostcomplete:interactive_comments:login_shell:progcomp:promptvars:sourcepath"
declare -ir BASHPID
...
```


#### 使用 expr 或 let 数值运算工具

例：使用expr进行数值运算
```
[root@localhost ~]# a=11
[root@localhost ~]# b=22
[root@localhost ~]# c=$(expr $a + $b)
[root@localhost ~]# echo $c
33
```
+号左右两侧必须要又空格

例：使用let进行数值运算
```
[root@localhost ~]# let d=$a+$b
[root@localhost ~]# echo $d
33
```

#### 使用 $(()) 或 $[] 运算

推荐使用 $(()) 方式进行数值运算

例：使用$(())进行运算
```
[root@localhost ~]# e=$(( $a+$b ))
[root@localhost ~]# echo $e
33
```
空格要求不严格，可以有空格也可以没有空格，默认都加上空格


### 运算符

|运算符|说明|
|-----|-|
|-,+  |单目负，单目正|
|!,~  |逻辑非，按位取反或补码|
|*,/,%|乘，除，取模|
|+,-  |加，减|
|<<,>>|按位左移，按位右移|
|<=,>=,<,>|小于等于，大于等于，小于，大于|
|==,!=|等于，不等于|
|$    |按位与|
|^    |按位异或|
|\|   |按位或|
|&&   |逻辑与|
|\|\| |逻辑或|
|=,+=,-=,*=,/=,%=,&=,^=,\|=,<<=,>>=|赋值，运算且赋值|

从上到下，优先级依次降低

例：加减乘除
```sh
[user@localhost ~]$ a=$(( (11+3)*3/2 ))
[user@localhost ~]$ echo $a
21
```

### 变量测试与内容置换

|变量置换方式|变量y没有设定|变量y为空值|变量y有值|
|-|-|-|-|
|x=${y-新值} |x=新值|x为空 |x=$y|
|x=${y:-新值}|x=新值|x=新值|x=$y|
|x=${y+新值} |x为空 |x=新值|x=新值|




## 环境变量配置文件


加载配置文件方式
```sh
[user@localhost ~]$ source 配置文件 
[user@localhost ~]$ . 配置文件
```

### 登陆生效的配置文件

* /etc/prifile
* /etc/profile.d/*.sh
* ~/.bash_profile
* ~/.bashrc
* /etc/bashrc


环境变量配置文件调用过程
```
登陆：
etc/profile --> ~/.bash_profile     --> ~/,bashrc   --> /etc/bashrc --> 命令提示符
            --> /etc/profile.d/*.sh

非登陆:
/etc/bashrc --> /etc/profile.d/*.sh
```
5个环境变量配置文件依次调用，按道理我们定义的环境变量放在哪一个环境变量配置文件都会生效，但建议 针对所有用户生效放入 /etc/profile，针对自己生效可以放在 ~/.bash_profile 或 ~/.bashrc

#### /etc/profile

* USER变量：根据登陆的用户，给这个变量赋值
* LOGNAME变量：根据USER变量的值，给这个变量赋值
* MAIL变量：根据登陆的用户，定义用户的邮箱目录，一般为 /var/spool/mail/用户名
* PATH变量：根据登陆用户的UID是否为0，判断PATH变量是否包含 /sbin,/usr/sbin./usr/local/sbin 三个系统命令目录
* HOSTNAME变量：主机名，给这个变量赋值
* HISTSIZE变量：定义历史命令的保存条数
* umask：定义umask默认权限，在用户登陆过程时才会生效
* 调用 /etc/profile.d/*.sh

#### ~/.bash_profile

* 在PATH变量后面加入 :&HOME/bin 这个目录，也就是说，我们在自己的家目录下，建立一个 bin 目录，把脚本放入 ~/bin 目录下，就能直接执行
* 调用 ~/.bashrc

#### ~/.bashrc

* 定义默认别名
* 调用 /etc/bashrc

#### /etc/bashrc

* PS1变量：也就是用户提示符，永久修改可以在这个文件修改
* umask：定义默认权限，但是是针对没有登陆过程
* PATH变量：给PATH变量追加值，针对没有登陆过程
* 调用/etc/prifile.d/*.sh

#### /etc/profile.d/*.sh

此目录下所有 以 .sh 结尾的文件都会被调用


### 注销生效的配置文件

```
~/.bash_logout
```
此配置文件默认为空，而且只能正常退出才生效，例如远程登陆直接关掉不生效

### shell登陆信息

#### /etc/issue

登陆本地终端，tty1-tty6时根据这个文件内容提示信息
```
[root@localhost ~]# cat /etc/issue
\S
Kernel \r on an \m
```
可以通过 man agetty 查询转义符
|转义符|作用|
|-|-|
|\d|显示当前系统日期|
|\s|显示操作系统名称|
|\l|显示登陆的终端号|
|\m|显示硬件体系结构|
|\n|显示主机名|
|\o|显示域名|
|\r|显示内核版本|
|\t|显示当前系统时间|
|\u|显示当前登陆用户的序列号|

#### /etc/issue.net

远程登陆(如ssh远程登陆，telnet远程登陆)显示的提示信息
* /etc/issue.net 不支持转义符
* ssh登陆是否显示 /etc/issue.net 的信息，需要修改ssh的配置文件


ssh的配置文件修改，让ssh登陆能够显示 /etc/issue.net 的提示信息，其实这里也可以设置为 /etc/issue 文件，但是远程登陆不会识别转义符，为了区分，建议使用 /etc/issue.net
```
[root@localhost ~]# cat /etc/ssh/sshd_config
...
# no default banner path
#Banner none
Banner /etc/issue.net
...
```

#### /etc/motd

在用户登陆之后提示的信息，无论远程登陆或本地登陆都生效










