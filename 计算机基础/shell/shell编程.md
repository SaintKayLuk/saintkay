# 正则表达式

包含匹配

## 基础正则表达式

```
元字符          作用
*           匹配前一个字符重复0次或任意多次
.           匹配除了换行符外的任意一个字符
[]          匹配中括号中任意一个字符，[abc] 代表匹配a,b,c其中一个，一个中括号代表匹配一个字符
                [-]中间加 - ，例如[a-z],代表一个小写字母
                [^] 取反，例如[^0-9],代表匹配一个不是数字的字符
^           匹配行首
$           匹配行尾
\           转义符，取消特殊符号的含义
\{n\}       匹配前一个字符恰好出现n次，例[0-9]\{4\}匹配4位数字     使用 grep -E 则不需要加反斜杠
\{n,\}      匹配前一个字符出现不少于n次                           使用 grep -E 则不需要加反斜杠       
\{n,m\}     匹配前一个字符至少出现n次，最多出现m次                 使用 grep -E 则不需要加反斜杠
```


例：匹配至少包含一个 a 的行数,在test.txt文本中
```
[root@localhost ~]# grep "aa*" test.txt
```
例：匹配除了换行符的任意两个个字符在a和c中间的行数
```
[root@localhost ~]# grep "a..c" test.txt
```
例：匹配所有,使用 .* 任意字符后面跟 * 都可以(例如a* b* )但是不推荐使用
```
[root@localhost ~]# grep ".*" test.txt
```
例：排除空白行，不推荐使用 .$ 排除空白行，-v 取反 
```
[root@localhost ~]# grep -v "^$" test.txt
```
例：匹配所有不是以数字开头的行
```
[root@localhost ~]# grep "^[^0-9]" test.txt
```

## 扩展正则表达式

shell中使用扩展正则需要使用 egrep 或 grep -E

```
元字符          作用
+           匹配前一个字符1次或任意多次，即大于等于1次
?           匹配前一个字符0次或1次
|           匹配两个或多个分支选择，如(dog|cat)+ 匹配 dog 或者 cat 一次或者多次，匹配的字符可以是 dog 也可以是 cat
()          匹配其整体作为一个字符，如(dog)+ 匹配 "dog" 出现一次或多次
```

例：匹配 hello world 或者 hello earth 在test。txt文件中
```
grep -E "hello (world|earth)" test.txt
```

# 字符处理

grep是找到符合条件的行，cut是找到符合条件的列

## 字符截取 cut 命令

```
cut [选项] 文件名
    -f  列号            提取第几列
    -d  分隔符          按照指定分隔符分割列，默认按照制表符(tab键)分割
    -c  字符范围        不依赖分隔符来区分列，例如 n- 表示从第n个字符到行尾，n-m 表示从第 n 个字符到第 m 个字符，-m表示从第一个字符到第 m 个字符
```



## print 和 printf

linux 命令行有 printf ，awk中使用print 作用相同，一般情况下，print只在awk中使用

printf格式化输出
```
printf '输出类型|输出格式' 输出内容
输出类型
    %ns     输出字符串，n是数字，输出几个字符
    %ni     输出整数，n是数字，输出几个数字
    %m.nf   输出浮点数，m和n是数字，指输出整数位数和小数位数，如 %8.2f 代表共输出8位数，其中2位是小数，6位是整数
输出格式
    \a      输出警告声音
    \b      输出退格键，也就是 backspace 键
    \f      清除屏幕
    \n      换行
    \r      回车，也就是 enter 键
    \t      水平输出退格键，也就是 Tab 键
    \v      垂直输出退格键，也就是 Tab 建
```
例：使用 printf 输出 test.txt 文件得内容,printf后面不能跟文件名，我们通过把命令结果作为 printf 得输出内容
```
[root@localhost ~]# printf '%s' `cat test.txt`
```

## awk

awk和cut相似，都是截取列，grep是根据条件截取符合的行，awk是截取符合条件的列
```
awk '条件1{动作1} 条件2{动作2} ...' 文件名
```

awk条件
```
条件        说明
BEGIN       在awk程序一开始，尚未读取任何数据之前执行，BEGIN后的动作只在程序开始时执行一次
END         在awk程序处理完所有数据，即将结束时执行，END后的动作只在程序结束时执行一次

>           大于
<           小于
>=          大于等于
<=          小于等于
==          等于
!=          不等于
A~B         判断字符串A中是否包含能匹配B表达式的子字符串
A!~B        判断字符串A中是否不包含能匹配B表达式的子字符串
/正则/      如果在 // 中可以写入字符，也可以支持正则表达式
```

例：条件可以不写，提取test.txt文件的第二列
```
[root@localhost ~]# awk '{print $2}' test.txt
```

有条件存在的情况下，只有条件成立动作才会执行，虽然awk是列提取命令，但是也按行来读入
1. 如有有 BEGIN 条件，则先执行 BEGIN 定义的动作 'BEGIN{动作}'
2. 如果没有 BEGIN 条件，则读入第一行，把第一行数据依次赋予 $0 $1 $2 等变量，其中 $0 是整行数据，$1 是第一字段，$2 是第二字段...
3. 根据条件类型判断动作是否执行，如果条件符合，则执行动作，否正读入下一行数据，如果没有条件，则每行都执行
4. 读入下一行数据，重复执行直至读完数据

例：输出第二字段包含 abc 的第六个字段
```
[root@localhost ~]# awk '$2 ~ /abc/ {print $4}' test.txt
```

| awk内置变量 | 作用                                     |
|-------------|----------------------------------------|
| $0          | 代表目前awk所读入的整行数据              |
| $n          | 代表目前读入行的第n个字段                |
| NF          | 当前行拥有的字段(列)总数                 |
| NR          | 当前awk所处理的行，是总列数的第几行       |
| FS          | 用户自定义分隔符，awk默认分隔符是任何空格 |
| ARGC        | 命令行参数个数                           |
| ARGV        | 命令行参数数组                           |
| FNR         | 当前文件中的当前记录数                   |
| OFMT        | 数值的输出个数，默认为 %.6g               |
| OFS         | 输出字符的分隔符，默认为空格              |
| ORS         | 输出记录分隔符，默认为换行符              |
| RS          | 输出记录分隔符，默认为换行符              |


例：以冒号为分隔符，输出 /etc/passwd 第一列，要改默认分隔符则必须放在BEGIN中，否则当awk读取第一行数据后才发现默认分隔符是其他，第一行不生效，其他内置变量类似
```
[root@localhost ~]# cat /etc/passwd | awk 'BEGIN{FS=":"} {print $1}'
```


## sed

sed命令主要用于将数据进行选取，替换，删除，新增
```
sed [选项] '[动作]' 文件名
选项：
    -n              一般sed命令会将所有数据都输出到屏幕，如果加入 -n 则只会输出经过sed命令处理过的数据
    -e              允许对输入数据应用多条sed命令编辑
    -f 脚本文件名   从sed脚本中读入sed操作，和awk命令的 -f 非常类似
    -r              在sed中支持扩展正则表达式
    -i              用sed的修改结果直接修改或读取原文件
动作：
    a\      追加，在当前行后添加一行或多行，添加多行时，每行末尾用 \ 代表数据未完结
    c\      行替换，用c后面的字符串替换原数据行，替换多行时，每行末尾加 \              
    i\      插入，在当前行前插入一行或多行
    d       删除，删除指定的行
    p       打印，输出指定的行
    s       字符串替换，格式为 行范围s/旧字符串/新字符串/g
```

测试文件test.txt
```
[root@localhost ~]# cat test.txt
11111
22222
33333
44444
55555
```
例：打印第二行数据
```
[root@localhost ~]# sed -n '2p' test.txt
22222
```
例：删除第2行到第4行数据,不加-i 则会把删除完的数据输出，加-i则会修改test.txt文件
```
[root@localhost ~]# sed '2,4d' test.txt
11111
55555
```
例：在第二行后追加2行数据
```
[root@localhost ~]# sed '2a hello \
> world' test.txt
11111
22222
hello 
world
33333
44444
55555
```


## sort

```
sort [选项] 文件名
    -f          忽略大小写
    -b          忽略每行前面的空白部分
    -n          以数值型进行排序，默认使用字符串型排序
    -r          反向排序
    -u          删除重复行，就是 uniq 命令
    -t          指定分隔符，默认分隔符是制表符
    -k n[,m]    按照指定的字段范围排序，从第n字段开始，m字段结束，没有m字段到行尾
```

例：以分隔符为 : 并以用户id的数值型对 /etc/passwd 进行排序
```
[root@localhost ~]# sort -n -t ":" -k 3,3 /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
...
```

uniq命令去除重复行，和sort -u 选项一样
```
uniq [选项] 文件名
    -i  忽略大小写
```


# 条件判断

## 判断文件类型
```
test [选项] 文件
    -b              判断文件是否存在，并且是否为块设备文件
    -c              判断文件是否存在，并且是否为字符设备文件
    -d              判断文件是否存在，并且是否为目录文件
    -e              判断文件是否存在，(存在为真)
    -f              判断文件是否存在，并且是否为普通文件
    -L              判断文件是否存在，并且是否为符号链接文件
    -p              判断文件是否存在，并且是否为管道文件
    -s              判断文件是否存在，并且是否为非空(非空为真)
    -S              判断文件是否存在，并且是否为套接字文件
```

在shell脚本中也可以使用[ 选项 文件] 来代替test命令

例：判断 /root/abc.txt文件是否存在，注意使用绝对路径
```
test -e /root/abc.txt 和 [ -e /root/abc.txt] 效果一样
```

## 判断文件权限
```
test [选项] 文件
    -r              判断文件是否存在，并且该文件有读权限
    -w              判断文件是否存在，并且该文件有写权限
    -x              判断文件是否存在，并且该文件有执行权限
    -u              判断文件是否存在，并且该文件有SUID权限
    -g              判断文件是否存在，并且该文件有SGID权限
    -k              判断文件是否存在，并且该文件有SBit权限
```

## 两个文件比较
```
test 文件1 [选项] 文件2
    -nt             判断文件1的修改时间是否比文件2的新
    -ot             判断文件1的修改时间是否比文件2的旧
    -ef             判断文件1和文件2的 Inode 号是否一致，用于判断硬链接的很好方法
```

## 两个整数比较
```
test 整数1 [选项] 整数2
    -eg             判断整数1是否和整数2相等
    -ne             判断整数1是否和整数2不相等
    -gt             判断整数1是否大于整数2
    -lt             判断整数1是否小于整数2
    -ge             判断整数1是否大于等于整数2
    -le             判断整数1是否小于等于整数2
```

例：判断整数23是否大于整数22，为真输出yes，为假输出no
```
[root@localhost ~]# [ 23 -gt 22 ] && echo yes || echo no
yes
```
## 判断字符串
```
test [选项] 字符串
    -z              判断字符串是否为空
    -n              判断字符串是否为非空

test 字符串1 == 字符串2     判断字符串1是否和字符串2相等
test 字符串1 != 字符串2     判断字符串1是否和字符串2不相等
```

## 多条件判断
```
判断1 -a 判断2      逻辑与，判断1和判断2都成立，则结果为真
判断1 -o 判断2      逻辑或，判断1和判断2有一个成立，结果为真
!判断               逻辑非，原始判断式取反，原判断为真，则最终结果为假，原判断为假，则最终结果为真
```

例：判断变量 a 是否有值，并且变量 a 的值大于23，为真输出 yes，为假输出 no
```
[root@localhost ~]# a=24
[root@localhost ~]# [ -n $a -a $a -gt 23 ] && echo yes || echo no
yes
```

# 流程控制

## if

then跟在条件判断式后面，需要加分号
```sh
if [ 条件判断式 ];then
    条件成立时，执行的程序
fi
```
推荐使用的if格式，then换行
```sh
if [ 条件判断式 ]
    then
        条件成立时，执行的程序
fi
```

```sh
if [ 条件判断式 ]
    then
        条件成立时，执行的程序
    else
        条件不成立时，执行的程序
fi
```

## case

```sh
case $变量名 in
    "值1")
        执行程序1
        ;;
    "值2")
        执行程序2
        ;;
    ...省略...
    *)
        都不是以上的值，执行此程序
        ;;
esac
```
例：判断变量num 等于1还是2还是3
```sh
case $num in
    "1")
        echo "变量等于1"
        ;;
    "2")
        echo "变量等于2"
        ;;
    "3")
        echo "变量等于3"
        ;;
    *)
        echo "都不是以上的值，则输出这句"
        ;;
esac
```

## for

语法一：循环 in 后面值的个数次，(用空格分隔)，每次循环把值赋值给变量
```sh
for 变量 in 值1 值2 值3 ...
    do
        循环体
    done

```
语法二：和大多数程序一样，通过条件判断来循环
```sh
for (( 初始值;循环控制条件;变量变化 ))
    do
        循环体
    done
```

对于脚本而言，语法一比较方便
例：批量解压 /tmp/tar/ 目录下的 .tar.gz 和 .tgz 结尾的压缩包
```sh
#!/bin/bash

cd /tmp/tar
# 进入压缩目录
ls *.tar.gz > ls.log
ls *.tgz >> ls.log
# 把所有 .tar.gz .tgz 结尾的文件名覆盖到 ls.log 文件中
for i in $(cat ls.log)
    do
        tar -zxvf $i
    done

rm -rf /tmp/tar/ls.log
# 删除临时文件
```

## while

while里面的条件判断式成立，则执行do和done里面的内容

```sh
while [ 条件判断式 ]
    do
        循环体
    done
```

例：求1到100的和 、
```sh
#!/bin/bash
i=1
s=0
while [ $i -le 100 ]
    do
        s=$(( $s+$i ))
        i=$(( $i+1 ))
    done
echo $s
```

## until

until里面的条件判断式不成立，则执行do和done里面的内容
```sh
until [ 条件判断式 ]
    do
        循环体
    done
```

## exit
在命令行中用于退出当前登录，在shell脚本中，用于终止当前程序，exit 后面的返回值，可以使用 $? 查看返回值

```sh
exit [ 返回值 ]
```

## break
跳出当前循环

## continue
结束单次当前循环


























