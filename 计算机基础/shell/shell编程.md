# 正则表达式

包含匹配

## 基础正则表达式

```
元字符          作用
*           匹配前一个字符重复0次或任意多次
.           匹配除了换行符外的任意一个字符
[]          匹配中括号中任意一个字符，[abc] 代表匹配a,b,c其中一个，一个中括号代表匹配一个字符
                [-]中间加 - ，例如[a-z],代表一个小写字母
                [^] 取反，例如[^0-9],代表匹配一个不是数字的字符
^           匹配行首
$           匹配行尾
\           转义符，取消特殊符号的含义
\{n\}       匹配前一个字符恰好出现n次，例[0-9]\{4\}匹配4位数字     使用 grep -E 则不需要加反斜杠
\{n,\}      匹配前一个字符出现不少于n次                           使用 grep -E 则不需要加反斜杠       
\{n,m\}     匹配前一个字符至少出现n次，最多出现m次                 使用 grep -E 则不需要加反斜杠
```


例：匹配至少包含一个 a 的行数,在test.txt文本中
```
[root@localhost ~]# grep "aa*" test.txt
```
例：匹配除了换行符的任意两个个字符在a和c中间的行数
```
[root@localhost ~]# grep "a..c" test.txt
```
例：匹配所有,使用 .* 任意字符后面跟 * 都可以(例如a* b* )但是不推荐使用
```
[root@localhost ~]# grep ".*" test.txt
```
例：排除空白行，不推荐使用 .$ 排除空白行，-v 取反 
```
[root@localhost ~]# grep -v "^$" test.txt
```
例：匹配所有不是以数字开头的行
```
[root@localhost ~]# grep "^[^0-9]" test.txt
```

## 扩展正则表达式

shell中使用扩展正则需要使用 egrep 或 grep -E

```
元字符          作用
+           匹配前一个字符1次或任意多次，即大于等于1次
?           匹配前一个字符0次或1次
|           匹配两个或多个分支选择，如(dog|cat)+ 匹配 dog 或者 cat 一次或者多次，匹配的字符可以是 dog 也可以是 cat
()          匹配其整体作为一个字符，如(dog)+ 匹配 "dog" 出现一次或多次
```

例：匹配 hello world 或者 hello earth 在test。txt文件中
```
grep -E "hello (world|earth)" test.txt
```

# 字符处理

grep是找到符合条件的行，cut是找到符合条件的列

## 字符截取 cut 命令

```
cut [选项] 文件名
    -f  列号            提取第几列
    -d  分隔符          按照指定分隔符分割列，默认按照制表符(tab键)分割
    -c  字符范围        不依赖分隔符来区分列，例如 n- 表示从第n个字符到行尾，n-m 表示从第 n 个字符到第 m 个字符，-m表示从第一个字符到第 m 个字符
```

## awk

## 1111111

# 条件判断

## 判断文件类型
```
test [选项] 文件
    -b              判断文件是否存在，并且是否为块设备文件
    -c              判断文件是否存在，并且是否为字符设备文件
    -d              判断文件是否存在，并且是否为目录文件
    -e              判断文件是否存在，(存在为真)
    -f              判断文件是否存在，并且是否为普通文件
    -L              判断文件是否存在，并且是否为符号链接文件
    -p              判断文件是否存在，并且是否为管道文件
    -s              判断文件是否存在，并且是否为非空(非空为真)
    -S              判断文件是否存在，并且是否为套接字文件
```

在shell脚本中也可以使用[ 选项 文件] 来代替test命令

例：判断 /root/abc.txt文件是否存在，注意使用绝对路径
```
test -e /root/abc.txt 和 [ -e /root/abc.txt] 效果一样
```

## 判断文件权限
```
test [选项] 文件
    -r              判断文件是否存在，并且该文件有读权限
    -w              判断文件是否存在，并且该文件有写权限
    -x              判断文件是否存在，并且该文件有执行权限
    -u              判断文件是否存在，并且该文件有SUID权限
    -g              判断文件是否存在，并且该文件有SGID权限
    -k              判断文件是否存在，并且该文件有SBit权限
```

## 两个文件比较
```
test 文件1 [选项] 文件2
    -nt             判断文件1的修改时间是否比文件2的新
    -ot             判断文件1的修改时间是否比文件2的旧
    -ef             判断文件1和文件2的 Inode 号是否一致，用于判断硬链接的很好方法
```

## 两个整数比较
```
test 整数1 [选项] 整数2
    -eg             判断整数1是否和整数2相等
    -ne             判断整数1是否和整数2不相等
    -gt             判断整数1是否大于整数2
    -lt             判断整数1是否小于整数2
    -ge             判断整数1是否大于等于整数2
    -le             判断整数1是否小于等于整数2
```

例：判断整数23是否大于整数22，为真输出yes，为假输出no
```
[root@localhost ~]# [ 23 -gt 22 ] && echo yes || echo no
yes
```
## 判断字符串
```
test [选项] 字符串
    -z              判断字符串是否为空
    -n              判断字符串是否为非空

test 字符串1 == 字符串2     判断字符串1是否和字符串2相等
test 字符串1 != 字符串2     判断字符串1是否和字符串2不相等
```

## 多条件判断
```
判断1 -a 判断2      逻辑与，判断1和判断2都成立，则结果为真
判断1 -o 判断2      逻辑或，判断1和判断2有一个成立，结果为真
!判断               逻辑非，原始判断式取反，原判断为真，则最终结果为假，原判断为假，则最终结果为真
```

例：判断变量 a 是否有值，并且变量 a 的值大于23，为真输出 yes，为假输出 no
```
[root@localhost ~]# a=24
[root@localhost ~]# [ -n $a -a $a -gt 23 ] && echo yes || echo no
yes
```

# 流程控制

## if

then跟在条件判断式后面，需要加分号
```sh
if [ 条件判断式 ];then
    条件成立时，执行的程序
fi
```
推荐使用的if格式，then换行
```sh
if [ 条件判断式 ]
    then
        条件成立时，执行的程序
fi
```

```sh
if [ 条件判断式 ]
    then
        条件成立时，执行的程序
    else
        条件不成立时，执行的程序
fi
```

扫描端口
```
nmap [选项] 域名或IP
    -s  扫描
    -T  扫描所有开启的TCP端口
```
例：扫描 ip为 11.22.33.44 的所有开启的tcp端口
```sh
namp -sT 11.22.33.44
```































